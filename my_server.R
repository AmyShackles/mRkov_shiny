library(mRkov)
library(dplyr)
library(DT)
my_server <- function(input, output) {
  # value holder
  v <- reactiveValues(data=NULL)
  # empty tweet data 
  v$tweet_data = NULL
  # empty stop word bank
  v$stopwords <- data.frame(word = character(),
                            stringsAsFactors = F)

  ######################################################
  #
  # Main Panel scripts
  #
  ######################################################
  
  # Outputs the name of the twitter handle being scraped
  output$message <- renderText({
    message_str <- NULL
    if (!is.null(v$username)) {
      message_str <- paste0("Scraping ", v$username, "!")
    }
    # return the string of text to be rendered
    message_str
  })
  
  # Outputs text telling the user how many tweets were found from user X
  output$tweets_found <- renderText({
    # Default message if no search has been performed
    message_str <- "Waiting for twitter search..."
    # if a search has been performed, display the number of tweets found
    if (is.null(v$tweet_data)) {
      message_str <- "No handle chosen!"
    } else if (("try-error" %in% c(class(v$tweet_data)))) {
      print("Found bad handle")
      message_str <- "Bad handle!"
    } else if (!is.null(v$tweet_data)) {
      message_str <- paste0("Found ", length(v$tweet_data$text), " tweets!",
                            "\nFinished at ",
                            substr(as.character(Sys.time()), 12, 19))
    }
    # return the string of text to be displayed
    message_str
  })

  # When the search button gets hit, run the tweet_gettr function
  observeEvent(
    input$search, {
      v$username <- input$username
      # if the handle is not valid, do not do anything
      v$tweet_data <- suppressWarnings(try(tweet_gettr(v$username,
                                                       includeRts = input$includeRts,
                                                       excludeReplies = input$excludeReplies),
                                           silent = TRUE)
                                       )
    }
  )

  
  observeEvent(input$make_sentence, {
    # if there is tweet data, generate a sentence
    if(!is.null(v$tweet_data)) {
      output <- ""
      
      for (n in 1:input$num_sentences) {
        text <- make_sentence(v$tweet_data, prompt = input$prompt)
        output <- paste0(output, make_html(text, v$tweet_data$twitter_meta[2], v$tweet_data$twitter_meta[1]))
      }
    } else {
      output <- "<p>Waiting for a sentence to be generated...</p>"
    }
    
    v$sentence <- HTML(output)
  })
  # Render a sentence generated by the script
  output$sentence <- renderUI({
    v$sentence
  })

  # Renders a wordcloud if there is twitter data
  output$plot <- renderPlot({
    if (!is.null(v$tweet_data)) {
      make_wordcloud(v$tweet_data,
                     pull(v$stopwords, word),
                     n = input$num_words)
    }
  }, height = 500, width = 500)
  
  ######################################################
  #
  # Sidebar Scripts
  #
  ######################################################
  
  # Add stop word to stopword bank when "add" button is pressed
  observeEvent(
    input$add_stop_word, {
      v$stopwords <- rbind(v$stopwords, 
                           data.frame(word = input$stop_word, stringsAsFactors = F))
    }
  )
  
  # Render the data table of stop words
  output$stopwords <- DT::renderDataTable({
    datatable(v$stopwords, options = list(dom = "t"))
  })
  
  # if the delete rows button is pressed, delete the selected rows
  observeEvent(input$deleteRows,{
    if (!is.null(input$stopwords_rows_selected)) {
      v$stopwords <- data.frame(word = v$stopwords[-as.numeric(input$stopwords_rows_selected),],
                                stringsAsFactors = F)
      }
  })

}
